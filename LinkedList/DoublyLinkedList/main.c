#include <stdio.h>
#include <stdlib.h>

// กำหนดโครงสร้างของโหนดในลิงก์ลิสต์แบบสองทิศทาง (Doubly Linked List)
typedef struct Node{
    struct Node* pre;    // ตัวชี้ไปยังโหนดก่อนหน้า (ใช้สำหรับเดินย้อนกลับ)
    int data;            // ข้อมูลที่เก็บในโหนด (ประเภทข้อมูลเป็นจำนวนเต็ม)
    struct Node* next;   // ตัวชี้ไปยังโหนดถัดไป (ใช้สำหรับเดินไปข้างหน้า)
} Node;

// ฟังก์ชัน createNode ใช้ในการสร้างโหนดใหม่และเก็บข้อมูลที่ต้องการลงในโหนดนั้น
// รับพารามิเตอร์:
// - int data: ข้อมูลที่จะเก็บในโหนดใหม่ (ประเภทข้อมูลเป็นจำนวนเต็ม)
// คืนค่า:
// - Node*: คืนค่าตัวชี้ไปยังโหนดใหม่ที่ถูกสร้างขึ้น
Node* createNode(int data) {
    // การจองพื้นที่ในหน่วยความจำสำหรับโหนดใหม่ โดยใช้ malloc
    Node* newNode = (Node *)malloc(sizeof(Node));

    // หากไม่สามารถจองพื้นที่ในหน่วยความจำได้ (malloc คืนค่า NULL) ให้แสดงข้อความผิดพลาดและหยุดการทำงาน
    if(!newNode){
        printf("Error: Allocation memory fieled!\n"); // แสดงข้อความผิดพลาด
        exit(1); // หยุดการทำงานของโปรแกรมทันที
    }

    // กำหนดค่าเริ่มต้นให้กับตัวชี้ pre และ next ของโหนดใหม่
    newNode->pre = NULL; // โหนดใหม่ไม่มีโหนดก่อนหน้า
    newNode->data = data; // เก็บข้อมูลที่ได้รับในพารามิเตอร์ data
    newNode->next = NULL; // โหนดใหม่ไม่มีโหนดถัดไป

    // คืนค่าตัวชี้ไปยังโหนดใหม่ที่ถูกสร้างขึ้น
    return newNode;
}


// ฟังก์ชัน showList ใช้ในการแสดงผลลิงก์ลิสต์ทั้งหมดจากหัวลิงก์ลิสต์จนถึงโหนดสุดท้าย
// รับพารามิเตอร์:
// - Node* node: ตัวชี้ไปยังโหนดแรก (หัว) ของลิงก์ลิสต์
// ฟังก์ชันนี้จะทำการแสดงผลลิงก์ลิสต์ในรูปแบบ [data1, data2, ..., dataN]
void showList(Node* node) {
    // แสดงสัญลักษณ์ "[" ที่จุดเริ่มต้นของการแสดงลิงก์ลิสต์
    printf("[");

    // ใช้ลูป while เพื่อเดินตามลิงก์ลิสต์จนถึงโหนดสุดท้าย
    while (node) {
        // ตรวจสอบว่าโหนดปัจจุบันเป็นโหนดสุดท้ายหรือไม่ (ถ้าไม่มี next ก็ถือว่าเป็นโหนดสุดท้าย)
        if (node->next == NULL) {
            // ถ้าเป็นโหนดสุดท้าย ให้พิมพ์ข้อมูลของโหนดโดยไม่ใส่เครื่องหมาย ","
            printf("%d", node->data);
        } else {
            // ถ้าไม่ใช่โหนดสุดท้าย ให้พิมพ์ข้อมูลของโหนดและตามด้วยเครื่องหมาย ","
            printf("%d, ", node->data);
        }
        // เลื่อนไปยังโหนดถัดไป (ใช้ node->next เพื่อเดินตามลิงก์ลิสต์)
        node = node->next;
    }

    // แสดงสัญลักษณ์ "]" ที่จุดสิ้นสุดของการแสดงลิงก์ลิสต์
    printf("]\n");
}


// ฟังก์ชัน freeList ใช้สำหรับการลบโหนดทั้งหมดในลิงก์ลิสต์
// รับพารามิเตอร์:
// - Node* head: ตัวชี้ไปยังหัวของลิงก์ลิสต์ที่ต้องการจะลบทุกโหนด
// ฟังก์ชันนี้จะทำการลบโหนดทั้งหมดในลิงก์ลิสต์เพื่อคืนพื้นที่หน่วยความจำ
void freeList(Node* head) {
    // ตัวแปร temp ใช้เก็บตัวชี้ชั่วคราวเพื่อช่วยในการลบโหนด
    Node* temp;

    // ใช้ลูป while เพื่อเดินตามลิงก์ลิสต์จนถึงโหนดสุดท้าย
    while (head) {
        // เก็บตัวชี้ไปยังโหนดถัดไป (head->next) ในตัวแปร temp
        temp = head->next;

        // ลบโหนดปัจจุบันโดยการใช้ free
        free(head);

        // เลื่อนไปยังโหนดถัดไป
        head = temp;
    }
}

// ฟังก์ชัน append ใช้ในการเพิ่มโหนดใหม่ไปยังท้ายของลิงก์ลิสต์
// รับพารามิเตอร์:
// - Node** head: ตัวชี้คู่ (double pointer) ไปยังหัวของลิงก์ลิสต์
// - int data: ข้อมูลที่จะเก็บในโหนดใหม่
// ฟังก์ชันนี้จะเพิ่มโหนดใหม่ไปยังตำแหน่งสุดท้ายของลิงก์ลิสต์
// และทำการเชื่อมโยงโหนดใหม่กับโหนดก่อนหน้าและโหนดถัดไป
int append(Node** head, int data) {
    // ถ้าลิงก์ลิสต์ว่าง (ไม่มีโหนดในลิสต์)
    if (*head == NULL) {
        // สร้างโหนดใหม่
        Node* newNode = createNode(data);
        
        // ตั้งค่าหัวลิงก์ลิสต์ให้ชี้ไปที่โหนดใหม่
        *head = newNode;

        // คืนค่า 0 เพื่อระบุว่าการเพิ่มโหนดสำเร็จ
        return 0;
    }

    // ถ้าลิงก์ลิสต์ไม่ว่าง สร้างโหนดใหม่
    Node* newNode = createNode(data);
    Node* temp = *head;

    // เดินตามลิงก์ลิสต์ไปจนถึงโหนดสุดท้าย
    while (temp) {
        // ถ้าเจอโหนดสุดท้าย (ไม่มีโหนดถัดไป)
        if (temp->next == NULL) {
            break;
        }

        // เดินไปยังโหนดถัดไป
        temp = temp->next;
    }

    // เชื่อมโยงโหนดใหม่ไปยังท้ายของลิงก์ลิสต์
    temp->next = newNode;

    // ตั้งค่าตัวชี้ pre ของโหนดใหม่ให้ชี้ไปยังโหนดก่อนหน้า (โหนดที่เป็นสุดท้ายก่อนหน้านี้)
    newNode->pre = temp;

    // คืนค่า 0 เพื่อระบุว่าการเพิ่มโหนดสำเร็จ
    return 0;
}

// ฟังก์ชัน sizeList ใช้ในการนับจำนวนโหนดในลิงก์ลิสต์
// รับพารามิเตอร์:
// - Node* node: ตัวชี้ไปยังโหนดแรกของลิงก์ลิสต์
// ฟังก์ชันนี้จะทำการเดินตามลิงก์ลิสต์ตั้งแต่โหนดแรกไปจนถึงโหนดสุดท้าย
// และจะนับจำนวนโหนดในลิสต์เพื่อคืนค่าเป็นจำนวนทั้งหมด
// คืนค่าจำนวนโหนดในลิงก์ลิสต์
int sizeList(Node* node) {
    // ตัวแปร count ใช้ในการนับจำนวนโหนด
    int count = 0;

    // เดินไปตามลิงก์ลิสต์
    while (node) {
        count++;            // เพิ่มค่าของ count ทุกครั้งที่เจอโหนด
        node = node->next;  // เดินไปยังโหนดถัดไป
    }

    // คืนค่าจำนวนโหนดทั้งหมด
    return count;
}

// ฟังก์ชัน updateNode ใช้ในการอัพเดตข้อมูลในโหนดที่ตำแหน่งที่กำหนดในลิงก์ลิสต์
// รับพารามิเตอร์:
// - Node* head: ตัวชี้ไปยังโหนดแรก (head) ของลิงก์ลิสต์
// - int pos: ตำแหน่งที่ต้องการอัพเดตข้อมูล (เริ่มจาก 1)
// - int data: ข้อมูลใหม่ที่จะใส่ในโหนดที่ตำแหน่งที่กำหนด
// คืนค่า 0 หากสำเร็จ และ 1 หากเกิดข้อผิดพลาด
int updateNode(Node* head, int pos, int data) {
    // ตรวจสอบว่าลิงก์ลิสต์ว่างหรือไม่
    if (!head) {
        printf("Error: List is null!\n"); // แสดงข้อความผิดพลาด
        return 1; // คืนค่า 1 เพื่อระบุข้อผิดพลาด
    }

    // ตรวจสอบว่าตำแหน่งที่ระบุอยู่ในช่วงที่ถูกต้อง
    if (pos > sizeList(head) || pos < 1) {
        printf("Error: Invalid position!\n"); // แสดงข้อความผิดพลาด
        return 1; // คืนค่า 1 เพื่อระบุข้อผิดพลาด
    }

    // เดินไปตามลิงก์ลิสต์จนถึงตำแหน่งที่ต้องการอัพเดต
    Node* temp = head;
    for (int i = 1; i < pos; i++) {
        temp = temp->next; // เดินไปยังโหนดถัดไป
    }

    // อัพเดตข้อมูลในโหนดที่ตำแหน่งที่กำหนด
    temp->data = data;

    // คืนค่า 0 เพื่อระบุว่าการอัพเดตสำเร็จ
    return 0;
}

// ฟังก์ชัน insertNode ใช้สำหรับแทรกโหนดใหม่ในตำแหน่งที่กำหนดในลิงก์ลิสต์
// รับพารามิเตอร์:
// - Node** head: ตัวชี้ไปยังโหนดแรกของลิงก์ลิสต์ (ใช้ตัวชี้คู่เพื่อสามารถเปลี่ยนแปลงค่าของ head ได้)
// - int pos: ตำแหน่งที่ต้องการแทรกโหนดใหม่ (เริ่มจาก 1)
// - int data: ข้อมูลที่ต้องการใส่ในโหนดใหม่
// คืนค่า 0 หากสำเร็จ และ 1 หากเกิดข้อผิดพลาด
int insertNode(Node** head, int pos, int data) {
    // ตรวจสอบว่าลิงก์ลิสต์ว่างหรือไม่ (หัวลิงก์ลิสต์เป็น NULL)
    if (!*head) {
        printf("Error: Node is null!\n");  // แสดงข้อความผิดพลาด
        return 1;  // คืนค่า 1 เพื่อระบุข้อผิดพลาด
    }

    // ตรวจสอบว่าตำแหน่งที่ระบุถูกต้องหรือไม่ (ตำแหน่งต้องมากกว่า 0 และไม่เกินขนาดของลิงก์ลิสต์)
    if (pos > sizeList(*head) || pos < 1) {
        printf("Error: Invalid position!\n");  // แสดงข้อความผิดพลาด
        return 1;  // คืนค่า 1 เพื่อระบุข้อผิดพลาด
    }

    // กรณีที่ต้องการแทรกที่ตำแหน่งแรก (pos == 1)
    if (pos == 1) {
        // สร้างโหนดใหม่ที่มีข้อมูลตามที่ระบุ
        Node* newNode = createNode(data);
        // เชื่อมต่อโหนดใหม่กับโหนดแรก (head)
        newNode->next = *head;  // ตัวชี้ `next` ของโหนดใหม่ชี้ไปยังโหนดแรก
        (*head)->pre = newNode; // ตัวชี้ `pre` ของโหนดแรกชี้กลับไปยังโหนดใหม่
        *head = newNode;        // เปลี่ยนตัวชี้หัวลิงก์ลิสต์ให้ชี้ไปยังโหนดใหม่
        return 0;  // คืนค่า 0 เพื่อระบุว่าการแทรกโหนดสำเร็จ
    }

    // กรณีที่ต้องการแทรกที่ตำแหน่งอื่นๆ
    Node* newNode = createNode(data);  // สร้างโหนดใหม่ที่มีข้อมูลตามที่ระบุ
    Node* temp = *head;
    
    // เดินไปยังตำแหน่งที่ต้องการแทรกโดยใช้ลูป
    for (int i = 1; i < pos; i++) {
        temp = temp->next;  // เดินไปยังโหนดถัดไป
    }

    // เก็บตัวชี้ไปยังโหนดก่อนหน้าและโหนดถัดไปที่ตำแหน่งที่ต้องการแทรก
    Node* bef = temp->pre;  // ตัวชี้ไปยังโหนดก่อนหน้า
    Node* aft = temp;       // ตัวชี้ไปยังโหนดถัดไป

    // การเชื่อมต่อโหนดใหม่เข้าในลิงก์ลิสต์
    bef->next = newNode;     // ตัวชี้ `next` ของโหนดก่อนหน้าชี้ไปยังโหนดใหม่
    newNode->pre = bef;      // ตัวชี้ `pre` ของโหนดใหม่ชี้ไปยังโหนดก่อนหน้า
    newNode->next = aft;     // ตัวชี้ `next` ของโหนดใหม่ชี้ไปยังโหนดถัดไป
    aft->pre = newNode;      // ตัวชี้ `pre` ของโหนดถัดไปชี้กลับไปยังโหนดใหม่

    return 0;  // คืนค่า 0 เพื่อระบุว่าการแทรกโหนดสำเร็จ
}

// ฟังก์ชัน deleteNode ใช้สำหรับลบโหนดที่ตำแหน่งที่กำหนดในลิงก์ลิสต์
// รับพารามิเตอร์:
// - Node** head: ตัวชี้ไปยังโหนดแรกของลิงก์ลิสต์ (ใช้ตัวชี้คู่เพื่อเปลี่ยนค่าของ head ได้)
// - int pos: ตำแหน่งของโหนดที่ต้องการลบ (เริ่มจาก 1)
// คืนค่า 0 หากสำเร็จ และ 1 หากเกิดข้อผิดพลาด
int deleteNode(Node** head, int pos) {
    // ตรวจสอบว่าลิงก์ลิสต์ว่างหรือไม่ (head เป็น NULL)
    if (!*head) {
        printf("Error: List is null!\n"); // แสดงข้อความผิดพลาด
        return 1; // คืนค่า 1 เพื่อระบุข้อผิดพลาด
    }

    // ตรวจสอบว่าตำแหน่งที่ระบุถูกต้องหรือไม่ (ตำแหน่งต้องไม่เกินขนาดลิงก์ลิสต์ และไม่ต่ำกว่า 1)
    if (pos > sizeList(*head) || pos < 1) {
        printf("Error: Invalid position!\n"); // แสดงข้อความผิดพลาด
        return 1; // คืนค่า 1 เพื่อระบุข้อผิดพลาด
    }

    // กรณีลบโหนดที่ตำแหน่งแรก (pos == 1)
    if (pos == 1) {
        Node* temp = *head;  // เก็บตัวชี้ไปยังโหนดแรก
        *head = temp->next;  // เปลี่ยนตัวชี้หัวลิงก์ลิสต์ไปยังโหนดถัดไป
        if (*head) {
            (*head)->pre = NULL; // ถ้ามีโหนดถัดไป, ให้ตัวชี้ pre ของโหนดถัดไปชี้กลับไปยัง NULL
        }
        free(temp); // ลบโหนดแรก
        return 0;   // คืนค่า 0 เพื่อระบุว่าการลบโหนดสำเร็จ
    }

    // กรณีลบโหนดที่ตำแหน่งสุดท้าย (pos == sizeList(*head))
    if (pos == sizeList(*head)) {
        Node* temp = *head;
        // เดินไปยังโหนดสุดท้าย
        while (temp) {
            if (temp->next == NULL) {
                break;
            }
            temp = temp->next;
        }
        Node* def = temp->pre; // เก็บตัวชี้ไปยังโหนดก่อนหน้าโหนดสุดท้าย
        def->next = NULL;       // ตัดการเชื่อมต่อจากโหนดสุดท้าย
        free(temp);             // ลบโหนดสุดท้าย
        return 0;               // คืนค่า 0 เพื่อระบุว่าการลบโหนดสำเร็จ
    }

    // กรณีลบโหนดที่ตำแหน่งกลางๆ (ตำแหน่งที่ไม่ใช่หัวและท้าย)
    Node* temp = *head;
    for (int i = 1; i < pos; i++) {
        temp = temp->next; // เดินไปยังโหนดที่ตำแหน่งที่ต้องการลบ
    }
    Node* pre = temp->pre;   // เก็บตัวชี้ไปยังโหนดก่อนหน้า
    Node* next = temp->next; // เก็บตัวชี้ไปยังโหนดถัดไป

    // เชื่อมต่อโหนดก่อนหน้าและโหนดถัดไป
    pre->next = next;        // ตัวชี้ next ของโหนดก่อนหน้าชี้ไปยังโหนดถัดไป
    if (next) {
        next->pre = pre;     // ถ้ามีโหนดถัดไป, ตัวชี้ pre ของโหนดถัดไปจะต้องชี้ไปยังโหนดก่อนหน้า
    }
    
    free(temp); // ลบโหนดที่ตำแหน่งที่ต้องการลบ
    return 0;   // คืนค่า 0 เพื่อระบุว่าการลบโหนดสำเร็จ
}


int main(){
    Node* head = NULL;

    append(&head, 10);
    append(&head, 20);
    append(&head, 30);
    append(&head, 40);
    append(&head, 50);

    showList(head);

    updateNode(head, 3, 300);
    showList(head);

    insertNode(&head, 1, 99);
    showList(head);

    deleteNode(&head, 6);
    showList(head);

    freeList(head);

    return 0;
}