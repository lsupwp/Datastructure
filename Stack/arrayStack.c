#include <stdio.h>
#include <stdlib.h>
#include <limits.h> // สำหรับ INT_MIN

// การประกาศโครงสร้าง Stack
typedef struct Stack {
    int top;
    unsigned capacity;
    int* array;
} Stack;

// การประกาศประเภทข้อมูล boolean
typedef int boolean;

#define TRUE 1
#define FALSE 0

// ฟังก์ชันต่างๆ
Stack* createStack(unsigned capacity);
boolean push(Stack* stack, int data);
boolean pop(Stack* stack);
int peek(Stack* stack);
boolean isEmpty(Stack* stack);
boolean isFull(Stack* stack);

int main() {
    // สร้างสแตกใหม่ที่มีความจุ 50
    Stack* stack1 = createStack(50);

    // เพิ่มข้อมูลลงในสแตก
    push(stack1, 10);
    push(stack1, 20);

    // ดูข้อมูลตัวบนสุด
    printf("%d\n", peek(stack1));

    // นำข้อมูลตัวบนสุดออก
    pop(stack1);
    // ดูข้อมูลตัวบนสุดหลังจากนำออก
    printf("%d\n", peek(stack1));

    // ปล่อยหน่วยความจำที่ใช้
    free(stack1->array);
    free(stack1);

    return 0; // ค่าที่คืนกลับเพื่อบ่งชี้ว่าโปรแกรมทำงานสำเร็จ
}

// ฟังก์ชันสำหรับสร้างสแตกที่มีความจุที่กำหนด
// พารามิเตอร์:
// - unsigned capacity: จำนวนสูงสุดของข้อมูลที่สามารถเก็บในสแตกได้
// คืนค่า:
// - ตัวชี้ (pointer) ไปยังโครงสร้างสแตกที่ถูกสร้างขึ้น
Stack* createStack(unsigned capacity) {
    // จองหน่วยความจำสำหรับโครงสร้างสแตก
    Stack* stack = (Stack *)malloc(sizeof(Stack));
    
    // ตรวจสอบว่าการจองหน่วยความจำสำหรับโครงสร้างสแตกสำเร็จหรือไม่
    if (!stack) {
        printf("Error: การจองหน่วยความจำล้มเหลว!\n");
        exit(1); // หยุดการทำงานของโปรแกรมพร้อมแจ้งรหัสข้อผิดพลาด
    }

    // กำหนดค่าเริ่มต้นให้ top เป็น -1 เพื่อแสดงว่าสแตกว่าง
    stack->top = -1;

    // กำหนดค่าความจุของสแตกให้ตรงกับค่าที่ส่งมา
    stack->capacity = capacity;

    // จองหน่วยความจำสำหรับอาร์เรย์ภายในที่ใช้เก็บข้อมูลในสแตก
    stack->array = (int *)malloc(stack->capacity * sizeof(int));
    
    // ตรวจสอบว่าการจองหน่วยความจำสำหรับอาร์เรย์สำเร็จหรือไม่
    if (!stack->array) {
        printf("Error: การจองหน่วยความจำล้มเหลว!\n");
        exit(1); // หยุดการทำงานของโปรแกรมพร้อมแจ้งรหัสข้อผิดพลาด
    }

    // คืนค่าตัวชี้ไปยังสแตกที่ถูกสร้าง
    return stack;
}


// ฟังก์ชันสำหรับเพิ่มข้อมูลเข้าไปในสแตก
// พารามิเตอร์:
// - Stack* stack: ตัวชี้ไปยังโครงสร้างสแตกที่ต้องการเพิ่มข้อมูล
// - int data: ข้อมูลที่ต้องการเพิ่มลงไปในสแตก
// คืนค่า:
// - TRUE: ถ้าการเพิ่มข้อมูลสำเร็จ
// - FALSE: ถ้าสแตกเต็มและไม่สามารถเพิ่มข้อมูลได้
boolean push(Stack* stack, int data) {
    // ตรวจสอบว่าสแตกเต็มหรือไม่ด้วยฟังก์ชัน isFull
    if (isFull(stack)) {
        printf("Error: stack is full!\n"); // แสดงข้อความแจ้งเตือนว่าสแตกเต็ม
        return FALSE; // คืนค่า FALSE เพื่อบอกว่าการเพิ่มข้อมูลล้มเหลว
    }

    // เพิ่มข้อมูลลงในสแตก:
    // เพิ่มค่า top ขึ้นทีละ 1 ก่อน (ด้วย ++stack->top) แล้วจัดเก็บข้อมูลที่ตำแหน่งนั้น
    stack->array[++stack->top] = data;

    // คืนค่า TRUE เพื่อบอกว่าการเพิ่มข้อมูลสำเร็จ
    return TRUE;
}


// ฟังก์ชันสำหรับนำข้อมูลออกจากสแตก
// พารามิเตอร์:
// - Stack* stack: ตัวชี้ไปยังโครงสร้างสแตกที่ต้องการนำข้อมูลออก
// คืนค่า:
// - TRUE: ถ้าการนำข้อมูลสำเร็จ
// - FALSE: ถ้าสแตกว่างและไม่สามารถนำข้อมูลออกได้
boolean pop(Stack* stack) {
    // ตรวจสอบว่าสแตกว่างหรือไม่ด้วยฟังก์ชัน isEmpty
    if (isEmpty(stack)) {
        printf("Error: stack is empty!\n"); // แสดงข้อความแจ้งเตือนว่าสแตกว่าง
        return FALSE; // คืนค่า FALSE เพื่อบอกว่าการนำข้อมูลล้มเหลว
    }

    // ลดค่า top ลง 1 เพื่อนำข้อมูลออก (ถือว่าข้อมูลถูกลบ)
    stack->top--;

    // คืนค่า TRUE เพื่อบอกว่าการนำข้อมูลสำเร็จ
    return TRUE;
}


// ฟังก์ชันสำหรับดูข้อมูลตัวบนสุดของสแตกโดยไม่ลบออก
// พารามิเตอร์:
// - Stack* stack: ตัวชี้ไปยังโครงสร้างสแตกที่ต้องการดูข้อมูล
// คืนค่า:
// - ค่าในตำแหน่งบนสุดของสแตก (stack->array[stack->top]) ถ้าสแตกไม่ว่าง
// - INT_MIN: ถ้าสแตกว่าง (เป็นค่าที่บอกว่าเกิดข้อผิดพลาด)
int peek(Stack* stack) {
    // ตรวจสอบว่าสแตกว่างหรือไม่ด้วยฟังก์ชัน isEmpty
    if (isEmpty(stack)) {
        printf("Error: Stack is empty!\n"); // แสดงข้อความแจ้งเตือนว่าสแตกว่าง
        return INT_MIN; // คืนค่า INT_MIN เพื่อบอกว่ามีข้อผิดพลาด
    }

    // คืนค่าข้อมูลในตำแหน่งบนสุดของสแตกโดยไม่ลบออก
    return stack->array[stack->top];
}

// ฟังก์ชันสำหรับตรวจสอบว่าสแตกว่างหรือไม่
// พารามิเตอร์:
// - Stack* stack: ตัวชี้ไปยังโครงสร้างสแตกที่ต้องการตรวจสอบ
// คืนค่า:
// - TRUE: ถ้าสแตกว่าง (ไม่มีข้อมูลในสแตก)
// - FALSE: ถ้าสแตกไม่ว่าง (มีข้อมูลอยู่ในสแตก)
boolean isEmpty(Stack* stack) {
    // ตรวจสอบว่า top ของสแตกมีค่าเท่ากับ -1 หรือไม่
    // ถ้า top == -1 หมายความว่าสแตกว่าง
    if (stack->top == -1) {
        return TRUE; // คืนค่า TRUE เพื่อบอกว่าสแตกว่าง
    }

    // ถ้า top ไม่เท่ากับ -1 หมายความว่าสแตกไม่ว่าง
    return FALSE; // คืนค่า FALSE
}


// ฟังก์ชันสำหรับตรวจสอบว่าสแตกเต็มหรือไม่
// พารามิเตอร์:
// - Stack* stack: ตัวชี้ไปยังโครงสร้างสแตกที่ต้องการตรวจสอบ
// คืนค่า:
// - TRUE: ถ้าสแตกเต็ม (ไม่สามารถเพิ่มข้อมูลได้อีก)
// - FALSE: ถ้าสแตกยังไม่เต็ม (สามารถเพิ่มข้อมูลได้)
boolean isFull(Stack* stack) {
    // ตรวจสอบว่า top ของสแตกมีค่าเท่ากับ capacity - 1 หรือไม่
    // ถ้า top == capacity - 1 หมายความว่าสแตกเต็ม
    if (stack->top == stack->capacity - 1) {
        return TRUE; // คืนค่า TRUE เพื่อบอกว่าสแตกเต็ม
    }

    // ถ้า top ยังไม่ถึงค่า capacity - 1 หมายความว่าสแตกยังไม่เต็ม
    return FALSE; // คืนค่า FALSE
}
